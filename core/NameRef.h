#ifndef RUBY_TYPER_NAMEREF_H
#define RUBY_TYPER_NAMEREF_H
#include "common/common.h"
#include "core/DebugOnlyCheck.h"
namespace sorbet::core {
class GlobalState;
class GlobalSubstitution;
class UniqueName;
class UTF8Name;
class ConstantName;
class Symbol;

struct NameDataDebugCheck {
    const GlobalState &gs;
    const unsigned int nameCountAtCreation;

    NameDataDebugCheck(const GlobalState &gs);
    void check() const;
};

/** This is to `NameRef &` what SymbolData is to `SymbolRef &`. Read docs on SymbolData */
class UniqueNameData : private DebugOnlyCheck<NameDataDebugCheck> {
    const UniqueName &name;

public:
    UniqueNameData(const UniqueName &ref, const GlobalState &gs);
    const UniqueName *operator->() const;
};
constexpr size_t sizeof__UniqueName = sizeof(UniqueName *);
constexpr size_t alignof__UniqueName = alignof(UniqueName *);
CheckSize(UniqueNameData, sizeof__UniqueName, alignof__UniqueName);

class UTF8NameData : private DebugOnlyCheck<NameDataDebugCheck> {
    const UTF8Name &name;

public:
    UTF8NameData(const UTF8Name &ref, const GlobalState &gs);
    const UTF8Name *operator->() const;
};
constexpr size_t sizeof__UTF8Name = sizeof(UTF8Name *);
constexpr size_t alignof__UTF8Name = alignof(UTF8Name *);
CheckSize(UniqueNameData, sizeof__UTF8Name, alignof__UTF8Name);

class ConstantNameData : private DebugOnlyCheck<NameDataDebugCheck> {
    const ConstantName &name;

public:
    ConstantNameData(const ConstantName &ref, const GlobalState &gs);
    const ConstantName *operator->() const;
};
constexpr size_t sizeof__ConstantName = sizeof(ConstantName *);
constexpr size_t alignof__ConstantName = alignof(ConstantName *);
CheckSize(UniqueNameData, sizeof__ConstantName, alignof__ConstantName);

struct NameRefDebugCheck {
    int globalStateId;

    constexpr NameRefDebugCheck() : globalStateId(-1) {}

    NameRefDebugCheck(const GlobalState &gs, u2 kind, u4 index);

    void check(const GlobalState &gs, u2 kind, u4 index) const;
    void check(const GlobalSubstitution &subst) const;
};

class NameRef final : private DebugOnlyCheck<NameRefDebugCheck> {
    friend UTF8Name;
    friend ConstantName;
    friend UniqueName;
    friend Symbol;

    u4 unsafeTableIndex() const {
        return _id & ID_MASK;
    }

    NameRef(u4 rawId) : _id(rawId){};

public:
    // If you add Symbol Kinds, make sure KIND_BITS is kept in sync!
    enum class Kind : u1 {
        // 0 is reserved for the non-existant NameRef.
        UTF8 = 1,
        UNIQUE = 2,
        CONSTANT = 3,
    };

    // Kind takes up this many bits in _id.
    static constexpr u4 KIND_BITS = 2;
    static constexpr u4 ID_BITS = 32 - KIND_BITS;
    static constexpr u4 ID_MASK = (1 << ID_BITS) - 1;

    NameRef() : _id(0){};

    // WellKnown is a tag to statically indicate that the caller is deliberately
    // constructing a well-known name, whose ID is stable across all
    // GlobalStates. This should never be used outside of the name constructors
    // generated by tools/generate_names.cc
    struct WellKnown {};

    constexpr NameRef(WellKnown, Kind kind, u4 id) : _id(id | (static_cast<u4>(kind) << ID_BITS)) {}

    NameRef(const GlobalState &gs, Kind kind, u4 id);

    NameRef(const NameRef &nm) = default;

    NameRef(NameRef &&nm) = default;

    const UTF8NameData utf8NameData(const core::GlobalState &gs) const;
    const ConstantNameData constantNameData(const core::GlobalState &gs) const;
    const UniqueNameData uniqueNameData(const core::GlobalState &gs) const;

    NameRef &operator=(const NameRef &rhs) = default;

    bool operator==(const NameRef &rhs) const {
        return _id == rhs._id;
    }

    bool operator!=(const NameRef &rhs) const {
        return !(rhs == *this);
    }

    static NameRef fromRaw(u4 rawId) {
        return NameRef(rawId);
    }

    constexpr inline u4 rawId() const {
        return _id;
    }

    // Returns the `0` NameRef, used to indicate non-existence of a name
    static NameRef noName() {
        return NameRef();
    }

    Kind kind() const {
        ENFORCE_NO_TIMER(_id != 0);
        return static_cast<Kind>(_id >> ID_BITS);
    }

    inline bool exists() const {
        return _id != 0;
    }

    inline u4 utf8Index() const {
        ENFORCE_NO_TIMER(kind() == Kind::UTF8);
        return unsafeTableIndex();
    }

    inline u4 uniqueIndex() const {
        ENFORCE_NO_TIMER(kind() == Kind::UNIQUE);
        return unsafeTableIndex();
    }

    inline u4 constantIndex() const {
        ENFORCE_NO_TIMER(kind() == Kind::CONSTANT);
        return unsafeTableIndex();
    }

    NameRef addEq(GlobalState &gs) const;
    NameRef addQuestion(GlobalState &gs) const;

    NameRef addAt(GlobalState &gs) const;

    NameRef prepend(GlobalState &gs, std::string_view s) const;

    NameRef lookupMangledPackageName(const GlobalState &gs) const;

    bool isClassName(const GlobalState &gs) const;

    // Convenience method, because enums need to be special cased in more places than other kinds of
    // unique names, and everyone always forget to unwrap the first layer (NameKind::CONSTANT)
    // before checking for UniqueNameKind::TEnum.
    bool isTEnumName(const GlobalState &gs) const;

    std::string_view shortName(const GlobalState &gs) const;
    std::string showRaw(const GlobalState &gs) const;
    std::string toString(const GlobalState &gs) const;
    std::string show(const GlobalState &gs) const;

    void enforceCorrectGlobalState(const GlobalState &gs) const;
    void sanityCheckSubstitution(const GlobalSubstitution &subst) const;

    unsigned int hash(const GlobalState &gs) const;
    void sanityCheck(const GlobalState &gs) const;

private:
    u4 _id;
};
CheckSize(NameRef, 4, 4);

template <typename H> H AbslHashValue(H h, const NameRef &m) {
    return H::combine(std::move(h), m.rawId());
}
} // namespace sorbet::core

#endif // RUBY_TYPER_NAMEREF_H
